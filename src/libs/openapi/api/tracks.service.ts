/**
 * Spotify Web API
 * You can use Spotify\'s Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { AddTracksToPlaylistRequest } from '../model/addTracksToPlaylistRequest';
// @ts-ignore
import { AudioAnalysisObject } from '../model/audioAnalysisObject';
// @ts-ignore
import { AudioFeaturesObject } from '../model/audioFeaturesObject';
// @ts-ignore
import { GetAnAlbum401Response } from '../model/getAnAlbum401Response';
// @ts-ignore
import { GetAnArtistsTopTracks200Response } from '../model/getAnArtistsTopTracks200Response';
// @ts-ignore
import { GetSeveralAudioFeatures200Response } from '../model/getSeveralAudioFeatures200Response';
// @ts-ignore
import { GetUsersTopArtistsAndTracks200Response } from '../model/getUsersTopArtistsAndTracks200Response';
// @ts-ignore
import { PagingPlaylistTrackObject } from '../model/pagingPlaylistTrackObject';
// @ts-ignore
import { PagingSavedTrackObject } from '../model/pagingSavedTrackObject';
// @ts-ignore
import { PagingSimplifiedTrackObject } from '../model/pagingSimplifiedTrackObject';
// @ts-ignore
import { RecommendationsObject } from '../model/recommendationsObject';
// @ts-ignore
import { RemoveTracksPlaylistRequest } from '../model/removeTracksPlaylistRequest';
// @ts-ignore
import { ReorderOrReplacePlaylistsTracks200Response } from '../model/reorderOrReplacePlaylistsTracks200Response';
// @ts-ignore
import { ReorderOrReplacePlaylistsTracksRequest } from '../model/reorderOrReplacePlaylistsTracksRequest';
// @ts-ignore
import { SaveAlbumsUserRequest } from '../model/saveAlbumsUserRequest';
// @ts-ignore
import { SaveTracksUserRequest } from '../model/saveTracksUserRequest';
// @ts-ignore
import { TrackObject } from '../model/trackObject';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class TracksService {

    protected basePath = 'https://api.spotify.com/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Add Items to Playlist 
     * Add one or more items to a user\&#39;s playlist. 
     * @param playlistId 
     * @param position 
     * @param uris 
     * @param requestBody 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTracksToPlaylist(playlistId: string, position?: number, uris?: string, requestBody?: { [key: string]: any; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ReorderOrReplacePlaylistsTracks200Response>;
    public addTracksToPlaylist(playlistId: string, position?: number, uris?: string, requestBody?: { [key: string]: any; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ReorderOrReplacePlaylistsTracks200Response>>;
    public addTracksToPlaylist(playlistId: string, position?: number, uris?: string, requestBody?: { [key: string]: any; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ReorderOrReplacePlaylistsTracks200Response>>;
    public addTracksToPlaylist(playlistId: string, position?: number, uris?: string, requestBody?: { [key: string]: any; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (playlistId === null || playlistId === undefined) {
            throw new Error('Required parameter playlistId was null or undefined when calling addTracksToPlaylist.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (position !== undefined && position !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>position, 'position');
        }
        if (uris !== undefined && uris !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uris, 'uris');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/playlists/${this.configuration.encodeParam({name: "playlistId", value: playlistId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/tracks`;
        return this.httpClient.request<ReorderOrReplacePlaylistsTracks200Response>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: requestBody,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Check User\&#39;s Saved Tracks 
     * Check if one or more tracks is already saved in the current Spotify user\&#39;s \&#39;Your Music\&#39; library. 
     * @param ids 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkUsersSavedTracks(ids: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<boolean>>;
    public checkUsersSavedTracks(ids: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<boolean>>>;
    public checkUsersSavedTracks(ids: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<boolean>>>;
    public checkUsersSavedTracks(ids: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling checkUsersSavedTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids !== undefined && ids !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ids, 'ids');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/me/tracks/contains`;
        return this.httpClient.request<Array<boolean>>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Album Tracks 
     * Get Spotify catalog information about an album’s tracks. Optional parameters can be used to limit the number of tracks returned. 
     * @param id 
     * @param market 
     * @param limit 
     * @param offset 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAnAlbumsTracks(id: string, market?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PagingSimplifiedTrackObject>;
    public getAnAlbumsTracks(id: string, market?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PagingSimplifiedTrackObject>>;
    public getAnAlbumsTracks(id: string, market?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PagingSimplifiedTrackObject>>;
    public getAnAlbumsTracks(id: string, market?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAnAlbumsTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/albums/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/tracks`;
        return this.httpClient.request<PagingSimplifiedTrackObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Artist\&#39;s Top Tracks 
     * Get Spotify catalog information about an artist\&#39;s top tracks by country. 
     * @param id 
     * @param market 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAnArtistsTopTracks(id: string, market?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetAnArtistsTopTracks200Response>;
    public getAnArtistsTopTracks(id: string, market?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetAnArtistsTopTracks200Response>>;
    public getAnArtistsTopTracks(id: string, market?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetAnArtistsTopTracks200Response>>;
    public getAnArtistsTopTracks(id: string, market?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAnArtistsTopTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/artists/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/top-tracks`;
        return this.httpClient.request<GetAnArtistsTopTracks200Response>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Track\&#39;s Audio Analysis 
     * Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track’s structure and musical content, including rhythm, pitch, and timbre. 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAudioAnalysis(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<AudioAnalysisObject>;
    public getAudioAnalysis(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<AudioAnalysisObject>>;
    public getAudioAnalysis(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<AudioAnalysisObject>>;
    public getAudioAnalysis(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAudioAnalysis.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audio-analysis/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<AudioAnalysisObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Track\&#39;s Audio Features 
     * Get audio feature information for a single track identified by its unique Spotify ID. 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAudioFeatures(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<AudioFeaturesObject>;
    public getAudioFeatures(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<AudioFeaturesObject>>;
    public getAudioFeatures(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<AudioFeaturesObject>>;
    public getAudioFeatures(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAudioFeatures.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audio-features/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<AudioFeaturesObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Playlist Items 
     * Get full details of the items of a playlist owned by a Spotify user. 
     * @param playlistId 
     * @param market 
     * @param fields 
     * @param limit 
     * @param offset 
     * @param additionalTypes 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPlaylistsTracks(playlistId: string, market?: string, fields?: string, limit?: number, offset?: number, additionalTypes?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PagingPlaylistTrackObject>;
    public getPlaylistsTracks(playlistId: string, market?: string, fields?: string, limit?: number, offset?: number, additionalTypes?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PagingPlaylistTrackObject>>;
    public getPlaylistsTracks(playlistId: string, market?: string, fields?: string, limit?: number, offset?: number, additionalTypes?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PagingPlaylistTrackObject>>;
    public getPlaylistsTracks(playlistId: string, market?: string, fields?: string, limit?: number, offset?: number, additionalTypes?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (playlistId === null || playlistId === undefined) {
            throw new Error('Required parameter playlistId was null or undefined when calling getPlaylistsTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }
        if (fields !== undefined && fields !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>fields, 'fields');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }
        if (additionalTypes !== undefined && additionalTypes !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>additionalTypes, 'additional_types');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/playlists/${this.configuration.encodeParam({name: "playlistId", value: playlistId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/tracks`;
        return this.httpClient.request<PagingPlaylistTrackObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Recommendations 
     * Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.  For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks. 
     * @param seedArtists 
     * @param seedGenres 
     * @param seedTracks 
     * @param limit 
     * @param market 
     * @param minAcousticness 
     * @param maxAcousticness 
     * @param targetAcousticness 
     * @param minDanceability 
     * @param maxDanceability 
     * @param targetDanceability 
     * @param minDurationMs 
     * @param maxDurationMs 
     * @param targetDurationMs 
     * @param minEnergy 
     * @param maxEnergy 
     * @param targetEnergy 
     * @param minInstrumentalness 
     * @param maxInstrumentalness 
     * @param targetInstrumentalness 
     * @param minKey 
     * @param maxKey 
     * @param targetKey 
     * @param minLiveness 
     * @param maxLiveness 
     * @param targetLiveness 
     * @param minLoudness 
     * @param maxLoudness 
     * @param targetLoudness 
     * @param minMode 
     * @param maxMode 
     * @param targetMode 
     * @param minPopularity 
     * @param maxPopularity 
     * @param targetPopularity 
     * @param minSpeechiness 
     * @param maxSpeechiness 
     * @param targetSpeechiness 
     * @param minTempo 
     * @param maxTempo 
     * @param targetTempo 
     * @param minTimeSignature 
     * @param maxTimeSignature 
     * @param targetTimeSignature 
     * @param minValence 
     * @param maxValence 
     * @param targetValence 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRecommendations(seedArtists: string, seedGenres: string, seedTracks: string, limit?: number, market?: string, minAcousticness?: number, maxAcousticness?: number, targetAcousticness?: number, minDanceability?: number, maxDanceability?: number, targetDanceability?: number, minDurationMs?: number, maxDurationMs?: number, targetDurationMs?: number, minEnergy?: number, maxEnergy?: number, targetEnergy?: number, minInstrumentalness?: number, maxInstrumentalness?: number, targetInstrumentalness?: number, minKey?: number, maxKey?: number, targetKey?: number, minLiveness?: number, maxLiveness?: number, targetLiveness?: number, minLoudness?: number, maxLoudness?: number, targetLoudness?: number, minMode?: number, maxMode?: number, targetMode?: number, minPopularity?: number, maxPopularity?: number, targetPopularity?: number, minSpeechiness?: number, maxSpeechiness?: number, targetSpeechiness?: number, minTempo?: number, maxTempo?: number, targetTempo?: number, minTimeSignature?: number, maxTimeSignature?: number, targetTimeSignature?: number, minValence?: number, maxValence?: number, targetValence?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RecommendationsObject>;
    public getRecommendations(seedArtists: string, seedGenres: string, seedTracks: string, limit?: number, market?: string, minAcousticness?: number, maxAcousticness?: number, targetAcousticness?: number, minDanceability?: number, maxDanceability?: number, targetDanceability?: number, minDurationMs?: number, maxDurationMs?: number, targetDurationMs?: number, minEnergy?: number, maxEnergy?: number, targetEnergy?: number, minInstrumentalness?: number, maxInstrumentalness?: number, targetInstrumentalness?: number, minKey?: number, maxKey?: number, targetKey?: number, minLiveness?: number, maxLiveness?: number, targetLiveness?: number, minLoudness?: number, maxLoudness?: number, targetLoudness?: number, minMode?: number, maxMode?: number, targetMode?: number, minPopularity?: number, maxPopularity?: number, targetPopularity?: number, minSpeechiness?: number, maxSpeechiness?: number, targetSpeechiness?: number, minTempo?: number, maxTempo?: number, targetTempo?: number, minTimeSignature?: number, maxTimeSignature?: number, targetTimeSignature?: number, minValence?: number, maxValence?: number, targetValence?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RecommendationsObject>>;
    public getRecommendations(seedArtists: string, seedGenres: string, seedTracks: string, limit?: number, market?: string, minAcousticness?: number, maxAcousticness?: number, targetAcousticness?: number, minDanceability?: number, maxDanceability?: number, targetDanceability?: number, minDurationMs?: number, maxDurationMs?: number, targetDurationMs?: number, minEnergy?: number, maxEnergy?: number, targetEnergy?: number, minInstrumentalness?: number, maxInstrumentalness?: number, targetInstrumentalness?: number, minKey?: number, maxKey?: number, targetKey?: number, minLiveness?: number, maxLiveness?: number, targetLiveness?: number, minLoudness?: number, maxLoudness?: number, targetLoudness?: number, minMode?: number, maxMode?: number, targetMode?: number, minPopularity?: number, maxPopularity?: number, targetPopularity?: number, minSpeechiness?: number, maxSpeechiness?: number, targetSpeechiness?: number, minTempo?: number, maxTempo?: number, targetTempo?: number, minTimeSignature?: number, maxTimeSignature?: number, targetTimeSignature?: number, minValence?: number, maxValence?: number, targetValence?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RecommendationsObject>>;
    public getRecommendations(seedArtists: string, seedGenres: string, seedTracks: string, limit?: number, market?: string, minAcousticness?: number, maxAcousticness?: number, targetAcousticness?: number, minDanceability?: number, maxDanceability?: number, targetDanceability?: number, minDurationMs?: number, maxDurationMs?: number, targetDurationMs?: number, minEnergy?: number, maxEnergy?: number, targetEnergy?: number, minInstrumentalness?: number, maxInstrumentalness?: number, targetInstrumentalness?: number, minKey?: number, maxKey?: number, targetKey?: number, minLiveness?: number, maxLiveness?: number, targetLiveness?: number, minLoudness?: number, maxLoudness?: number, targetLoudness?: number, minMode?: number, maxMode?: number, targetMode?: number, minPopularity?: number, maxPopularity?: number, targetPopularity?: number, minSpeechiness?: number, maxSpeechiness?: number, targetSpeechiness?: number, minTempo?: number, maxTempo?: number, targetTempo?: number, minTimeSignature?: number, maxTimeSignature?: number, targetTimeSignature?: number, minValence?: number, maxValence?: number, targetValence?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (seedArtists === null || seedArtists === undefined) {
            throw new Error('Required parameter seedArtists was null or undefined when calling getRecommendations.');
        }
        if (seedGenres === null || seedGenres === undefined) {
            throw new Error('Required parameter seedGenres was null or undefined when calling getRecommendations.');
        }
        if (seedTracks === null || seedTracks === undefined) {
            throw new Error('Required parameter seedTracks was null or undefined when calling getRecommendations.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }
        if (seedArtists !== undefined && seedArtists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>seedArtists, 'seed_artists');
        }
        if (seedGenres !== undefined && seedGenres !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>seedGenres, 'seed_genres');
        }
        if (seedTracks !== undefined && seedTracks !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>seedTracks, 'seed_tracks');
        }
        if (minAcousticness !== undefined && minAcousticness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minAcousticness, 'min_acousticness');
        }
        if (maxAcousticness !== undefined && maxAcousticness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAcousticness, 'max_acousticness');
        }
        if (targetAcousticness !== undefined && targetAcousticness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetAcousticness, 'target_acousticness');
        }
        if (minDanceability !== undefined && minDanceability !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minDanceability, 'min_danceability');
        }
        if (maxDanceability !== undefined && maxDanceability !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxDanceability, 'max_danceability');
        }
        if (targetDanceability !== undefined && targetDanceability !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetDanceability, 'target_danceability');
        }
        if (minDurationMs !== undefined && minDurationMs !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minDurationMs, 'min_duration_ms');
        }
        if (maxDurationMs !== undefined && maxDurationMs !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxDurationMs, 'max_duration_ms');
        }
        if (targetDurationMs !== undefined && targetDurationMs !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetDurationMs, 'target_duration_ms');
        }
        if (minEnergy !== undefined && minEnergy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minEnergy, 'min_energy');
        }
        if (maxEnergy !== undefined && maxEnergy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxEnergy, 'max_energy');
        }
        if (targetEnergy !== undefined && targetEnergy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetEnergy, 'target_energy');
        }
        if (minInstrumentalness !== undefined && minInstrumentalness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minInstrumentalness, 'min_instrumentalness');
        }
        if (maxInstrumentalness !== undefined && maxInstrumentalness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxInstrumentalness, 'max_instrumentalness');
        }
        if (targetInstrumentalness !== undefined && targetInstrumentalness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetInstrumentalness, 'target_instrumentalness');
        }
        if (minKey !== undefined && minKey !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minKey, 'min_key');
        }
        if (maxKey !== undefined && maxKey !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxKey, 'max_key');
        }
        if (targetKey !== undefined && targetKey !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetKey, 'target_key');
        }
        if (minLiveness !== undefined && minLiveness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minLiveness, 'min_liveness');
        }
        if (maxLiveness !== undefined && maxLiveness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxLiveness, 'max_liveness');
        }
        if (targetLiveness !== undefined && targetLiveness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetLiveness, 'target_liveness');
        }
        if (minLoudness !== undefined && minLoudness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minLoudness, 'min_loudness');
        }
        if (maxLoudness !== undefined && maxLoudness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxLoudness, 'max_loudness');
        }
        if (targetLoudness !== undefined && targetLoudness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetLoudness, 'target_loudness');
        }
        if (minMode !== undefined && minMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minMode, 'min_mode');
        }
        if (maxMode !== undefined && maxMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxMode, 'max_mode');
        }
        if (targetMode !== undefined && targetMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetMode, 'target_mode');
        }
        if (minPopularity !== undefined && minPopularity !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minPopularity, 'min_popularity');
        }
        if (maxPopularity !== undefined && maxPopularity !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxPopularity, 'max_popularity');
        }
        if (targetPopularity !== undefined && targetPopularity !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetPopularity, 'target_popularity');
        }
        if (minSpeechiness !== undefined && minSpeechiness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minSpeechiness, 'min_speechiness');
        }
        if (maxSpeechiness !== undefined && maxSpeechiness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxSpeechiness, 'max_speechiness');
        }
        if (targetSpeechiness !== undefined && targetSpeechiness !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetSpeechiness, 'target_speechiness');
        }
        if (minTempo !== undefined && minTempo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minTempo, 'min_tempo');
        }
        if (maxTempo !== undefined && maxTempo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxTempo, 'max_tempo');
        }
        if (targetTempo !== undefined && targetTempo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetTempo, 'target_tempo');
        }
        if (minTimeSignature !== undefined && minTimeSignature !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minTimeSignature, 'min_time_signature');
        }
        if (maxTimeSignature !== undefined && maxTimeSignature !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxTimeSignature, 'max_time_signature');
        }
        if (targetTimeSignature !== undefined && targetTimeSignature !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetTimeSignature, 'target_time_signature');
        }
        if (minValence !== undefined && minValence !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minValence, 'min_valence');
        }
        if (maxValence !== undefined && maxValence !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxValence, 'max_valence');
        }
        if (targetValence !== undefined && targetValence !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetValence, 'target_valence');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/recommendations`;
        return this.httpClient.request<RecommendationsObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Tracks\&#39; Audio Features 
     * Get audio features for multiple tracks based on their Spotify IDs. 
     * @param ids 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeveralAudioFeatures(ids: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetSeveralAudioFeatures200Response>;
    public getSeveralAudioFeatures(ids: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetSeveralAudioFeatures200Response>>;
    public getSeveralAudioFeatures(ids: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetSeveralAudioFeatures200Response>>;
    public getSeveralAudioFeatures(ids: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling getSeveralAudioFeatures.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids !== undefined && ids !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ids, 'ids');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audio-features`;
        return this.httpClient.request<GetSeveralAudioFeatures200Response>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Several Tracks 
     * Get Spotify catalog information for multiple tracks based on their Spotify IDs. 
     * @param ids 
     * @param market 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeveralTracks(ids: string, market?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetAnArtistsTopTracks200Response>;
    public getSeveralTracks(ids: string, market?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetAnArtistsTopTracks200Response>>;
    public getSeveralTracks(ids: string, market?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetAnArtistsTopTracks200Response>>;
    public getSeveralTracks(ids: string, market?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling getSeveralTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }
        if (ids !== undefined && ids !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ids, 'ids');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tracks`;
        return this.httpClient.request<GetAnArtistsTopTracks200Response>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Track 
     * Get Spotify catalog information for a single track identified by its unique Spotify ID. 
     * @param id 
     * @param market 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTrack(id: string, market?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<TrackObject>;
    public getTrack(id: string, market?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<TrackObject>>;
    public getTrack(id: string, market?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<TrackObject>>;
    public getTrack(id: string, market?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTrack.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tracks/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<TrackObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get User\&#39;s Saved Tracks 
     * Get a list of the songs saved in the current Spotify user\&#39;s \&#39;Your Music\&#39; library. 
     * @param market 
     * @param limit 
     * @param offset 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUsersSavedTracks(market?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PagingSavedTrackObject>;
    public getUsersSavedTracks(market?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PagingSavedTrackObject>>;
    public getUsersSavedTracks(market?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PagingSavedTrackObject>>;
    public getUsersSavedTracks(market?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (market !== undefined && market !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>market, 'market');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/me/tracks`;
        return this.httpClient.request<PagingSavedTrackObject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get User\&#39;s Top Items 
     * Get the current user\&#39;s top artists or tracks based on calculated affinity. 
     * @param type 
     * @param timeRange 
     * @param limit 
     * @param offset 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUsersTopArtistsAndTracks(type: 'artists' | 'tracks', timeRange?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetUsersTopArtistsAndTracks200Response>;
    public getUsersTopArtistsAndTracks(type: 'artists' | 'tracks', timeRange?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetUsersTopArtistsAndTracks200Response>>;
    public getUsersTopArtistsAndTracks(type: 'artists' | 'tracks', timeRange?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetUsersTopArtistsAndTracks200Response>>;
    public getUsersTopArtistsAndTracks(type: 'artists' | 'tracks', timeRange?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getUsersTopArtistsAndTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (timeRange !== undefined && timeRange !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>timeRange, 'time_range');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/me/top/${this.configuration.encodeParam({name: "type", value: type, in: "path", style: "simple", explode: false, dataType: "'artists' | 'tracks'", dataFormat: undefined})}`;
        return this.httpClient.request<GetUsersTopArtistsAndTracks200Response>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove Playlist Items 
     * Remove one or more items from a user\&#39;s playlist. 
     * @param playlistId 
     * @param removeTracksPlaylistRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeTracksPlaylist(playlistId: string, removeTracksPlaylistRequest?: RemoveTracksPlaylistRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ReorderOrReplacePlaylistsTracks200Response>;
    public removeTracksPlaylist(playlistId: string, removeTracksPlaylistRequest?: RemoveTracksPlaylistRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ReorderOrReplacePlaylistsTracks200Response>>;
    public removeTracksPlaylist(playlistId: string, removeTracksPlaylistRequest?: RemoveTracksPlaylistRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ReorderOrReplacePlaylistsTracks200Response>>;
    public removeTracksPlaylist(playlistId: string, removeTracksPlaylistRequest?: RemoveTracksPlaylistRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (playlistId === null || playlistId === undefined) {
            throw new Error('Required parameter playlistId was null or undefined when calling removeTracksPlaylist.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/playlists/${this.configuration.encodeParam({name: "playlistId", value: playlistId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/tracks`;
        return this.httpClient.request<ReorderOrReplacePlaylistsTracks200Response>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: removeTracksPlaylistRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove User\&#39;s Saved Tracks 
     * Remove one or more tracks from the current user\&#39;s \&#39;Your Music\&#39; library. 
     * @param ids 
     * @param requestBody 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public removeTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public removeTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public removeTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling removeTracksUser.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids !== undefined && ids !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ids, 'ids');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/me/tracks`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: requestBody,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Playlist Items 
     * Either reorder or replace items in a playlist depending on the request\&#39;s parameters. To reorder items, include &#x60;range_start&#x60;, &#x60;insert_before&#x60;, &#x60;range_length&#x60; and &#x60;snapshot_id&#x60; in the request\&#39;s body. To replace items, include &#x60;uris&#x60; as either a query parameter or in the request\&#39;s body. Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist. &lt;br/&gt; **Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters. These operations can\&#39;t be applied together in a single request. 
     * @param playlistId 
     * @param uris 
     * @param requestBody 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reorderOrReplacePlaylistsTracks(playlistId: string, uris?: string, requestBody?: { [key: string]: any; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ReorderOrReplacePlaylistsTracks200Response>;
    public reorderOrReplacePlaylistsTracks(playlistId: string, uris?: string, requestBody?: { [key: string]: any; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ReorderOrReplacePlaylistsTracks200Response>>;
    public reorderOrReplacePlaylistsTracks(playlistId: string, uris?: string, requestBody?: { [key: string]: any; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ReorderOrReplacePlaylistsTracks200Response>>;
    public reorderOrReplacePlaylistsTracks(playlistId: string, uris?: string, requestBody?: { [key: string]: any; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (playlistId === null || playlistId === undefined) {
            throw new Error('Required parameter playlistId was null or undefined when calling reorderOrReplacePlaylistsTracks.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (uris !== undefined && uris !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>uris, 'uris');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/playlists/${this.configuration.encodeParam({name: "playlistId", value: playlistId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/tracks`;
        return this.httpClient.request<ReorderOrReplacePlaylistsTracks200Response>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: requestBody,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Save Tracks for Current User 
     * Save one or more tracks to the current user\&#39;s \&#39;Your Music\&#39; library. 
     * @param ids 
     * @param requestBody 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public saveTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public saveTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public saveTracksUser(ids: string, requestBody?: { [key: string]: any; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling saveTracksUser.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids !== undefined && ids !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ids, 'ids');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (oauth_2_0) required
        localVarCredential = this.configuration.lookupCredential('oauth_2_0');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/me/tracks`;
        return this.httpClient.request<any>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: requestBody,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
